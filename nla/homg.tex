% nladoc.tex V2.0, 13 May 2010

\documentclass[times]{nlaauth}

\usepackage{moreverb}

\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,trees,snakes} %,decorations.pathreplacing,fit}
% \usepackage{tkz-euclide}
\usepackage{pgfplots}
\usepackage{subcaption}
% \usetkzobj{all} 

\definecolor{utorange}{RGB}{203,96,21}
\definecolor{utblack}{RGB}{99,102,106}
\definecolor{utbrown}{RGB}{110,98,89}
\definecolor{utsecbrown}{RGB}{217,200,158}
\definecolor{utsecgreen}{RGB}{208,222,187}
\definecolor{utsecblue}{RGB}{127,169,174}


\newcommand{\todo}[1]{\textcolor{red}{\bf #1}}
\newcommand{\gsnote}[1]{\textcolor{blue}{GS: #1}}


\newcommand\BibTeX{{\rmfamily B\kern-.05em \textsc{i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\def\volumeyear{2013}

\begin{document}

\runningheads{Sundar~et~al.}{High-order Geometric Multigrid}

\title{Comparison of Geometric Multigrid Algorithms for High-order Finite Element Discretizations}

\author{Hari Sundar\corrauth, Georg Stadler, Omar Ghattas and George Biros}

\address{Institute for Computational Engineering \& Sciences, University of Texas, Austin, TX 78712}

\corraddr{\texttt{hari@ices.utexas.edu}}

\begin{abstract}
\input {homg_abstract.tex}
\end{abstract}

\keywords{geometric multigrid, high-order finite elements, p-multigrid}

\maketitle


\section{Introduction}

This paper presents a systematic comparision of geometric multigrid
algorithms for the solution of systems arising from high-order (we
target polynomial orders up to XX) discretizations of elliptic partial
differential equations. Our particular interest is to compare the
efficiency of different high-order multigrid methods for problems with
varying coefficients and complex geometry.

While we use moderate size model problems for the comparisons in this
paper, we also discuss our findings with regard to parallel
implementations on high performance computing platforms.  In
particular, we discuss (1) matrix-free methods, i.e., methods that do
not require assembled finite element matrices, and (2) their
parallelization on shared or distributed memory architectures.
% and (3)
% cache-efficient methods with dominantly local memory access.

High order spatial discretizations can have significant advantages
over low order methods, especially when the solution is smooth and
high accuracy is desired. However, the sparsity of finite element (or
finite difference) operators decreases as the polynomial approximation
order increases, which makes the application of high order operators
to vectors computationally significantly more expensive. This is also
true if matrix-free methods are used, i.e., system matrices are never
assembled, but their application on vectors is implemented through
elemental loops.  Besides the loss of sparsity, another challenge in
high-order discretizations is due to the fact that the discretization
matrices loose structural properties such as the M-matrix property,
which allows to prove convergence of iterative solvers such as the
Jacobi or Gauss-Seidel method.

\noindent
\gsnote{Needs a literature review.}\\
\gsnote{Unify notion of mesh/grid etc}\\
\gsnote{Unify use of high order vs.\ higher order}\\

Although there are examples of using Algebraic Multigrid directly on
operators resulting from higher-order discretizations, limited work
has been done on using geometric multigrid with higher-order
discretizations. To the best of our knowledge, no prior work on using
geometric multigrid for solving systems arising from higher-order
discretizations on arbitrary geometries using highly adapted meshes.



%In this work, we develop
%geometric multigrid methods to support higher-order discretizations
%($1\le p\le 8$) and compare  against preconditioning using the
%co-located linear operator.

% We evaluate using variable-coefficient
%Poisson problems on $2D$ and $3D$ domains. We demonstrate that by
%using appropriate inter-grid transfer operators and smoothers,
%mesh-independent convergence is possible ($1\le p\le8$) for the {\em
%direct} approach. For the direct approach, best results are obtained
%using the symmetric successive over-relaxation (SSOR) smoother. We
%conclude with thoughts on the parallelization of the proposed
%approach.\\[2ex]


%\section{Meshing, High-order FEM}

\gsnote{Section should contain:
\begin{itemize}
\item We prefer hexahedra, motivated from spectral methods. Main
  advantage is tensorized basis functions (and, octree adaptivity)
\item High-order maps better to current architectures (could go into
  intro as well)
\end{itemize}
}

%Our method is designed for meshes that are built from an unstructured
%hexahedral macro mesh, in which each macro element is adaptively
%refined as an octree. This forest-of-octrees approach enables us to
%generate meshes for complex geometries with arbitrary levels of local
%refinement. We use geometric multigrid (GMG) for each of the octrees
%and algebraic multigrid (AMG) as the coarse grid solver. We designed
%our GMG sweeps to entirely avoid collectives, thus minimizing
%communication cost. Recently \cite{SundarBirosBursteddeEtAl12}, we
%presented weak and strong scaling results for the 3D
%variable-coefficient Poisson problem using linear discretization that
%demonstrate high parallel scalability. Here we explore various
%approaches for extending our geometric multigrid solver to support
%higher-order discretizations.

For three-dimensional hexahedral mesh finite element discretizations
with polynomial degree $p$, element matrices are of size
$n=(p+1)^3$. The naive assembly and application of these elemental
matrices requires $\mathcal O(p^9)$ operatrions, but exploiting the
tensor structure of the basis functions allows to reduce this to
$\mathcal O(p^7)$ operations.


\section{Approaches for High-order Multigrid}
\label{sec:approaches}
% talk about the 4 main approaches and prior work.

In this section, we summarize different approaches to geometric
multigrid for higher-order finite element discretizations; see
Figure~\ref{fig:approaches}. These methods can either be directly used
as solvers, or as preconditioners within Krylov methods.

\begin{figure}
		% illustration for p-multigrid
		\begin{tikzpicture}
		% homg
		\draw (-5,4) grid +(4,1);
		\foreach \e in {-5,...,-2}
		\foreach \x in {0,0.1727,0.5,0.8273, 1.0} {
			\draw[fill=utsecblue] (\e+\x, 4) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 4.1727) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 4.5) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 4.8273) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 5) circle (0.03);
		}
		%\node at (5,4.5) {\small $p=4$};
		\draw[-latex',thick] (-3, 3.75) -- node[right] {{\scriptsize $h$-coarsen}} (-3, 3.25);
		\draw (-5,2) rectangle +(4,1);
		\draw (-3,2) -- (-3,3);
		\foreach \e in {-5,-3}
		\foreach \x in {0,0.1727,0.5,0.8273, 1.0} {
			\draw[fill=utsecblue] (\e+2*\x, 2) circle (0.03);
			\draw[fill=utsecblue] (\e+2*\x, 2.1727) circle (0.03);
			\draw[fill=utsecblue] (\e+2*\x, 2.5) circle (0.03);
			\draw[fill=utsecblue] (\e+2*\x, 2.8273) circle (0.03);
			\draw[fill=utsecblue] (\e+2*\x, 3) circle (0.03);
		}
		%\node at (5,2.5) {\small $p=2$};
	
		\draw[-latex',thick] (-3, 1.75) -- node[right] {{\scriptsize $h$-coarsen}} (-3, 1.25);
	
		\draw (-5,0) rectangle +(4,1);
		\foreach \x in {0,0.1727,0.5,0.8273, 1.0} {
			\draw[fill=utsecblue] (-5+4*\x, 0) circle (0.03);
			\draw[fill=utsecblue] (-5+4*\x, 0.1727) circle (0.03);
			\draw[fill=utsecblue] (-5+4*\x, 0.5) circle (0.03);
			\draw[fill=utsecblue] (-5+4*\x, 0.8273) circle (0.03);
			\draw[fill=utsecblue] (-5+4*\x, 1) circle (0.03);
		}
		
	%% p-multigrid
		\draw (0,4) grid +(4,1);
		\foreach \e in {0,...,3}
		\foreach \x in {0,0.1727,0.5,0.8273, 1.0} {
			\draw[fill=utsecblue] (\e+\x, 4) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 4.1727) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 4.5) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 4.8273) circle (0.03);
			\draw[fill=utsecblue] (\e+\x, 5) circle (0.03);
		}
		%\node at (5,4.5) {\small $p=4$};
	
		\draw[-latex',thick] (2, 3.75) -- node[right] {{\scriptsize $p$-coarsen}} (2, 3.25);
	
		\draw (0,2) grid +(4,1);
		\foreach \x in {0,0.5,...,4} {
			\draw[fill=utsecblue] (\x, 2) circle (0.03);
			\draw[fill=utsecblue] (\x, 2.5) circle (0.03);
			\draw[fill=utsecblue] (\x, 3) circle (0.03);
		}
		%\node at (5,2.5) {\small $p=2$};
	
		\draw[-latex',thick] (2, 1.75) -- node[right] {{\scriptsize $p$-coarsen}} (2, 1.25);
	
		\draw (0,0) grid +(4,1);
		\foreach \x in {0,1,2,3,4} {
			\draw[fill=utsecblue] (\x, 0) circle (0.05);
			\draw[fill=utsecblue] (\x, 1) circle (0.05);
		}
		%\node at (5,0.5) {\small $p=1$};
		
		%% collocated
			\draw (5,4) grid +(4,1);
			\foreach \e in {5,...,8}
			\foreach \x in {0,0.1727,0.5,0.8273, 1.0} {
				\draw[fill=utsecblue] (\e+\x, 4) circle (0.03);
				\draw[fill=utsecblue] (\e+\x, 4.1727) circle (0.03);
				\draw[fill=utsecblue] (\e+\x, 4.5) circle (0.03);
				\draw[fill=utsecblue] (\e+\x, 4.8273) circle (0.03);
				\draw[fill=utsecblue] (\e+\x, 5) circle (0.03);
			}
			%\node at (2, 1.8) {\tiny $p=4$};
	
			\draw[-latex',thick] (7, 3.75) -- node[right] {{\scriptsize precondition}} (7, 1.25);
	
			\draw[step=0.5] (4.99,0) grid +(4.01,1);
			\draw (5,0.1727) -- (9,0.1727);
			\draw (5,0.8273) -- (9,0.8273);
			\foreach \e in {5,...,8} {
				\draw (\e+0.1727,0) -- (\e+0.1727,1);
				\draw (\e+0.8273,0) -- (\e+0.8273,1);
				\foreach \x in {0,0.1727,0.5,0.8273, 1.0} {
					\draw[fill=utsecblue] (\e+\x, 0) circle (0.03);
					\draw[fill=utsecblue] (\e+\x, 0.1727) circle (0.03);
					\draw[fill=utsecblue] (\e+\x, 0.5) circle (0.03);
					\draw[fill=utsecblue] (\e+\x, 0.8273) circle (0.03);
					\draw[fill=utsecblue] (\e+\x, 1) circle (0.03);
				}
			}
			% \node at (2, -0.2) {\tiny $p=1$ collocated with $p=4$};
		\end{tikzpicture}
		\caption{\label{fig:approaches} Different approaches
                  for high-order multigrid: High-order $h$-multigrid
                  (left), $p$-multigrid (middle) and low-order
                  preconditioned multigrid.}
\end{figure}

\subsection{$h$-multigrid}\label{subsec:h}
A direct approach to high-order multigrid is to use high order
restriction and prolongation operators, and use the higher-order
discretization of the operator for the residual computation on each
multigrid level.  A potential difficulty in this approach is that it
requires smoothers for matrices arising from high order
discretization, which usually have less favorable properties compared
to their low order counterparts; For instance, higher-order
discretizations of scalar elliptic operators are usually not
M-matrices, which is a useful property to prove the convergence of
smoothers such as Jacobi of Gauss-Seidel.  Due to the decreased
sparsity of high-order discretized systems, the efficient computation
of the residual can be a challenge. As a remedy, one can use
matrix-free methods which do not require to assemble system matrices
but rely on element-local computations. The performance of these
element-local computations can often be speed up using tensorized
finite element basis functions as common in spectral element methods;
see e.g.~\cite{DevilleFischerMund02}.


\subsection{$p$-multigrid}\label{subsec:p}
In the $p$-multigrid approach to high order multigrid, one (initially)
does not coarsen the mesh geometrically, but coarsens the system by
reducing the polynomial order. Starting from an order-$p$ polynomial
basis (for simplicity, we assume here that $p$ is a power of 2), the
coarser grids correspond to polynomials of order $p/2, p/4,\ldots,1$,
followed by geometric coarsening of the $p=1$ grid (i.e., the usual
low order geometric multigrid). Decreasing the polynomial order is an
element-local operation and is particularly simple for discretizations
with nonconforming meshes. \gsnote{Is that actually true?}. As for
high-order $h$-multigrid, devising smoothers is a challenge for
$p$-multigrid.  Moreover, one often finds dependence of the
convergence factor on the order of the polynomial basis. \gsnote{We
  need a citation here.}

\subsection{Defect correction using lower-order operator}\label{subsec:low}
Using a defect correction approach (see
\cite{TrottenbergOosterleeSchuller01}), the high order defect can
iteratively be corrected using a low order operator obtained by
overlaying the higher-order nodes with a lower-order (typically
linear) finite element mesh.  This construction of a low-order
preconditioner based on the nodes of the high order discretization is
also used for instance
in~\cite{Brown10,Kim07,DevilleMund90,HeysManteuffelMcCormickEtAl05}.
The resulting method is nearly independent of $p$, but this low-order
preconditioning is not work optimal and the convergence factors can be
lower than when multigrid is applied directly to the higher-order
operator. \gsnote{Cite or remove statement.} Defect correction only
requires to compute the residual for the high order discretized
operator, while the smoothing is based on the low order discretized
operator, which is sparse and thus much faster to apply.

Unfortunately, due to the non uniformly node spacing inherited from
the high-order discretization, the solution of the low order system is
not straightforward.  Additionally, for nonconforming meshes the
constructing the low order operator can be technical at edges and
faces of different size; while the basis functions for the high order
operators can be made continuous through the use of algebraic
constraints at nonconforming faces, the corresponding low order
discretization has discontinuities at nonconforming faces.

One possible approach to solve the low order system is to rely on
algebraic multigrid,
e.g.,~\cite{Brown10,HeysManteuffelMcCormickEtAl05}.



% multigrid cycles are faster compared to high
%order $h$-multigrid or $p$-multigrid discussed in
%Section~\ref{subsec:h} and Section~\ref{subsec:p}, respectively.

%Standard multigrid is then used for the low order operator, which has
%more favorable sparsity properties and thus allows for standard
%smoothers.
%  Thus, the speedup for a full multigrid cycle when using the
%low order operator is limited.


%The advantages of doing
%this are mainly in the simplicity of the approach and the availability
%of parallel multigrid solvers capable of solving such lower-order
%operators.
% The sparsity of the lower-order operators also permits the
%use of AMG for solving the lower-order operators, possibly obtained
%via discretizations on unstructured meshes.



\section{Smoothers}
Here, we summarize smoothers 


\subsection{Point smoothers}



\subsection{Schwarz-based methods}\label{subsec:schwarz}
Another common approach for solving systems arising from higher-order
discretizations is based on local block solves.  The main challenge
with these approaches is that they require solving dense local blocks
either using direct methods or approximations that allow for fast
iterative solution \cite{LottesFischer05,FischerLottes05}. These
methods have been used successfully for spectral element
discretizations with orders significantly larger than 8. However, the
coarse-grid solves can become fairly expensive and is not
straightforward to achieve good parallel scalability. \gsnote{This is
  a particular choice of smoother, not of multigrid...right?}




\section{Performance}
To compare the computational cost of the different methods, we focus
on matrix-vector multiplications on the finest multigrid level, which
dominate the overall computation. Denoting the number of unknowns on
the finest level by $N$, the cost for a matrix-vector product is
$Ng_p$, where $g_p>0$ is the cost per unknown for the application of
an operator originating from a discretization with finite element of
order $p$. Higher order discretizations result in less sparse
operators and thus $g_1\le g_2\le \ldots$. However, the actual value
of $g_p$, however, depends strongly on the implemenation and on the
system architecture. To illustrate this, consider an elemental matrix
for a hexahedral mesh in three dimensions, which is dense and of size
$(p+1)^3\times (p+1)^3$. Its naive application to a vector amounts to
$\mathcal O((p+1)^9)$ operations; for tensor bases, as common in
spectral element methods, this can be reduced to $\mathcal O((p+1)^7)$
operations \cite{DevilleFischerMund02}. In addition, high-order
implementations allow more memory locality, which, compared to low
order methods, results in higher performance.

Based on this simple performance model, we next summarize the
computational cost of the approaches to high-oder multigrid discussed
in Section~\ref{sec:approaches}. We denote by $s_\text{pre}$ and
$s_\text{post}$ the number of pre- and post-smoothing steps on the
finest multigrid level, respectively. Note that smoothers such as
Jacobi, SSOR and Chebyshev internally use matrix-vector products, and
we denote by $m$ the number of products per smoothing step.  Jacobi
smoothing and Chebyshev-accelerated Jacobi require $m=1$ matrix-vector
multiplication per smoothing step, while SSOR requires $m=2$
matrix-vector operations.


\begin{itemize}
\item {\em High-order $h$-multigrid:} On the finest grid level, the
  residual and the smoothing steps are all based on the order $p$
  discretization. Thus, the cost based on the matrix-vector products
  on the finest multigrid level is
  $g_p(1+m(s_\text{pre}+s_\text{post}))$.

\item {\em $p$-multigrid:} As for high-order $h$-multigrid, an
  estimate for the computational cost on the finest level is
  $g_p(1+m(s_\text{pre}+s_\text{post}))$.

\item {\em High-order defect correction with linear-order operator:}
  High-order defect correction requires the computation of the
  high-order residual, but uses smoothing based on the low-order
  operator. Using linear elements, the computational cost on the
  finest grid level is thus
  $g_p+g_1m(s_\text{pre}+s_\text{post})$.


\end{itemize}





\section{Evaluation}

Present results here and analyze based on performance model.

\input{results.tex}

\section{Discussion and conclusions}

%Finalize and discuss ramifications.

\begin{itemize}
\item Using multigrid with Jacobi and Jacobi-based Chebyshev smoothing
  as solver either fails to converge or converges slowly at orders
  $p\ge 4$.
\item Using Jacobi-based multigrid as preconditioner in the conjugate
  gradient method, the number of iterations for polynomial orders
  $p=2,3$ is similar to the number of iterations for linear elements.
  In general, for the same number of unknowns one can expect better
  accuracy for higher polynomial order. This advantage has to be
  contrasted with the fact that higher order operators are less sparse
  and thus their application to vectors is more time consuming.  Using
  Jacobi-based smoothers is attractive from a parallel perspective
  since no coloring of unknowns as in SSOR is necessary.
\item Both, high-order $h$-multigrid as well as $p$-multigrid yield
  significantly faster convergence in terms of the number of
  iterations than preconditioning with the low-order
  operator. Although low order operators are sparser and thus faster
  to apply, the significant larger number of iterations results in
  larger time-to-solution, in particular since the high-order operator
  must be used to compute the residual on the finest mesh.
\item For problems that only require a small number of smoothing
  steps, using Chebyshev acceleration for the Jacobi smoother does not
  improve the convergence. In all our tests, SSOR smoothing results in
  the fastest convergence, in particular for orders $p\ge
  4$. \gsnote{Revisit.}
\end{itemize}


\bibliographystyle{wileyj}
\bibliography{mg,ccgo}


\end{document}
